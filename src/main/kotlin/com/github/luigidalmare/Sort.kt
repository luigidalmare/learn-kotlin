/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.github.luigidalmare

class Sort {

    fun selectionSort(input: MutableList<Int>) {
        var currentIndex: Int = input.size
        while (currentIndex > 0) {
            val unsortedPortion = input.subList(0, currentIndex)
            val min = unsortedPortion.min()
            unsortedPortion.remove(min!!)
            input.add(min)
            currentIndex--
        }
    }

    fun insertionSort(input: MutableList<Int>) {
        var currentIndex: Int = 0
        while (currentIndex < input.size) {
            val currentValue = input.get(currentIndex)
            for (nextIndex in 0..currentIndex) {
                val nextSortedValue = input.get(nextIndex)
                if (currentValue < nextSortedValue){
                    input.removeAt(currentIndex)
                    input.add(nextIndex, currentValue)
                    break
                }
            }
            currentIndex++
        }
    }

    fun bubbleSort(input: MutableList<Int>) {
        for (i in 1..(input.size-1)){
            for(j in i downTo 1){
                val candidate = input.get(j)
                val previous = input.get(j-1)
                if (candidate < previous){
                    input.removeAt(j)
                    input.add(j-1, candidate)
                } else {
                    break
                }
            }
        }
    }

    fun mergeSort(input: MutableList<Int>) : MutableList<Int> {
        if (input.size <=1){
            return input
        }
        val pivotIndex = input.size / 2
        val leftList = mutableListOf(*input.subList(0, pivotIndex).toTypedArray())
        val rightList = mutableListOf(*input.subList(pivotIndex, input.size).toTypedArray())
        val sortedLeft = mergeSort(leftList)
        val sortedRight = mergeSort(rightList)
        val result = mutableListOf<Int>()

        while(result.size < input.size){
            if (!(sortedLeft.isEmpty() || sortedRight.isEmpty())){
                val n1 = sortedLeft[0]
                val n2 = sortedRight[0]
                if (n1 < n2) {
                    sortedLeft.removeAt(0)
                    result.add(n1)
                } else {
                    sortedRight.removeAt(0)
                    result.add(n2)
                }
            } else if(sortedLeft.isEmpty()){
               result.addAll(sortedRight)
           } else if(sortedRight.isEmpty()){
               result.addAll(sortedLeft)
           }
        }
        return result
    }



    fun quickSort(input: List<Int>) : List<Int> {
        if (input.isEmpty()){
            return input
        }
        val pivotIndex = input.size / 2
        val pivotVal = input.get(pivotIndex)
        val left = mutableListOf<Int>()
        val right = mutableListOf<Int>()
        for(i in 0..(input.size-1)){
            if(i == pivotIndex){
                continue
            }
            val curVal = input.get(i)
            if(curVal < pivotVal){
                left.add(curVal)
            } else {
                right.add(curVal)
            }
        }
        val leftSorted = quickSort(left)
        val rightSorted = quickSort(right)
        val result : MutableList<Int> = mutableListOf()
        result.addAll(leftSorted)
        result.add(pivotVal)
        result.addAll(rightSorted)
        return result
    }
}


